<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Meteor trajectory viewer</title>
    <script src="https://code.jquery.com/jquery-3.5.0.js"></script>

    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
    <link rel="icon" type="image/x-icon" href="favicon.ico" />

    <script src="https://unpkg.com/papaparse@5.3.0/papaparse.min.js"
    integrity="sha384-fU3JmTM3BACOkkqkyvCkZsp5gC4snA8QP4b7tOxoRl8duHf6pxMO0g/YlxM4izL3"
    crossorigin=""></script>

    <link rel="stylesheet" href="mystyle.css" />

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"
    integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A=="
    crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"
    integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA=="
    crossorigin=""></script>

    <script src="https://unpkg.com/@mapbox/leaflet-pip@latest/leaflet-pip.js"></script>

    <script src="https://unpkg.com/leaflet.locatecontrol@0.72.0/src/L.Control.Locate.js"
    integrity="sha384-PSVTmppejJh0R+0VYiO5WfFwPwEhGaGi+vAg+amhVMPBgQIEynPFz44Qw/CzyAgA"
    crossorigin=""></script>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.locatecontrol@0.72.0/dist/L.Control.Locate.min.css"
    integrity="sha384-vPNGCZwbWwO+u7VXCcmLEJRcz/YmtXGdC3LOF8O4/IvddhfpYZI1O0tJszYkbsD2"
    crossorigin="" />

    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css"
    integrity="sha384-lPzjPsFQL6te2x+VxmV6q1DpRxpRk0tmnl2cpwAO5y04ESyc752tnEWPKDfl1olr"
    crossorigin="" />
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster-src.js"
    integrity="sha384-N9K+COcUk7tr9O2uHZVp6jl7ueGhWsT+LUKUhd/VpA0svQrQMGArhY8r/u/Pkwih"
    crossorigin=""></script>

    <script src='//api.tiles.mapbox.com/mapbox.js/plugins/leaflet-omnivore/v0.3.1/leaflet-omnivore.min.js'></script>

    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>

    <link href="https://unpkg.com/tabulator-tables@4.9.3/dist/css/tabulator_midnight.min.css" rel="stylesheet" />
    <script type="text/javascript" src="https://unpkg.com/tabulator-tables@4.9.3/dist/js/tabulator.min.js"></script>

    <script type="text/javascript" src="established.json"></script>

    <script>
        var mymap;
        var meteorLayer;
        var fovLayer;
        var selectedMeteorIds = [];
        var jsonData;
        var meteorTable;
        var stationsIndex; // Differs between CAMS and RMS
        var stationLayers = {};
        var fovLayers = {};
        var stationMarkerLayers;
        var establishedShowers = JSON.parse(establishedStr);

        $(function () {
            var holder = document.getElementById('mapid');

            holder.ondragover = function() {
                return false;
            };
            holder.ondragend = function() {
                return false;
            };
            holder.ondrop = function(e) {
                var file = e.dataTransfer.files[0];
                reader = new FileReader();
                reader.onload = function(event) {
                    if (file.name.includes(".KML") || file.name.includes(".kml")) {
                        console.log(event.target.result);
                        loadCamsFov(event.target.result);
                    } else {
                        var csvData = event.target.result.replace(/\r/g, "");
                        addMeteorsToMap(csvData);
                        panToExtent();
                    }
                };
                reader.readAsText(file);

                return false;
            };

            mymap = L.map('mapid', {maxZoom: 12}).setView([52.3, 5], 8);
            var CartoDB_DarkMatter = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors ' +
                             '&copy; <a href="https://carto.com/attributions">CARTO</a>; ' +
                             '&copy; CC-BY 4.0 <a href="https://globalmeteornetwork.org/data/">Global Meteor Network</a>',
                subdomains: 'abcd',
                maxZoom: 18,
                minZoom: 3
            });
            CartoDB_DarkMatter.addTo(mymap);
            L.control.locate({drawCircle: false, drawMarker: false, locateOptions: {
                maxZoom: 10
            }}).addTo(mymap);

            fovLayer = new L.FeatureGroup();
            fovLayer.on("add", reorderLayers);

            meteorLayer = new L.FeatureGroup();
            meteorLayer.on("add", reorderLayers);
            meteorLayer.addTo(mymap);

            mymap.on('zoomend', fixStationScale);
            mymap.on('click', fovClickHandler);

            addStationsToMap();
            loadFov();

            const queryString = window.location.search;
            const urlParams = new URLSearchParams(queryString);
            var urlStations = urlParams.get("stations");
            if (urlStations) {
                document.getElementById("stationsFilter").value = urlStations;
            }

            meteorTable = new Tabulator("#meteortable", {
                data: [],
                index: "0",
                columns: getColumnDefinitions(false),
                rowClick:function(e, row) {
                    var meteorId = row.getPosition();
                    selectMeteor(meteorId);
                    var leafletId = jsonData.data[meteorId].leafletId;
                    var selectedFeature = meteorLayer.getLayer(leafletId);
                    mymap.flyTo(selectedFeature.getBounds().getCenter(), 8);
                },
                selectable: 1,
                layout: "fitData",
                layoutColumnsOnNewData:true
            });
            updateFilter();

            $("#stationsFilter").change(updateFilter);
            $("#stationsFilter").keyup(updateFilter);

            var initialDataset = urlParams.get("data");
            if (initialDataset) {
                if (initialDataset.length == 7) {
                    var year = initialDataset.slice(0, 4);
                    var month = initialDataset.slice(5);
                    var url = "https://www.tammo80.nl/camsfiles/monthly/SML-" + year + month + ".txt";
                    document.getElementById("dailymonthly_daily").checked = false;
                    document.getElementById("dailymonthly_monthly").checked = true;
                } else {
                    var url = "https://www.tammo80.nl/camsfiles/daily/SML-" + initialDataset + ".txt";
                }
                dailyMonthlyChange(); // This will populate the dropdown
                getMeteorsFromUrl(url);
            } else {
                dailyMonthlyChange(true); // Populate dropdown and load data
            }
        });

        function reorderLayers() {
            fovLayer.bringToBack();
            meteorLayer.bringToFront();
            for (var i in stationMarkerLayers) {
                stationMarkerLayers[i].bringToFront();
            }
        }

        function updatePermalink() {
            var permalink = document.getElementById("permalink");
            var datasetdropdown = document.getElementById("datasetDropdown");
            var selecteddatasetindex = datasetdropdown.selectedIndex;

            var stationliststr = document.getElementById("stationsFilter").value;

            var newlink = "?stations=" + stationliststr;

            if (selecteddatasetindex != -1) {
                newlink += "&data=" + datasetdropdown.options[selecteddatasetindex].text;
            }

            permalink.href = newlink;
        }

        function chooseStationMarkerLayer(stationType) {
            // 0: none, 1: CAMS (clustered), 2: CAMS, 3: RMS
            if (mymap.hasLayer(stationMarkerLayers[0])) {
                // Don't add stations to the map if they were removed manually
                return;
            }
            for (var i=0; i<4; i++) {
                if (i==stationType) {
                    mymap.addLayer(stationMarkerLayers[i]);
                } else {
                    mymap.removeLayer(stationMarkerLayers[i]);
                }
            }
        }

        //custom file formatter
        var kmlFormatter = function(list, options, setFileContents){
            //list - an array of export rows representing one row of data for the table;
            //options - the options object passed from the download function
            //setFileContents - function to call to pass the formatted data to the downloader

            var fileContents = [];
            var headers = [];

            fileContents.push(`<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://earth.google.com/kml/2.2">
  <Document>
    <name>Meteors from the Global Meteor Network</name>
    <open>1</open>
    <description>
      <![CDATA[Courtesy of <a href=" http://www.globalmeteornetwork.org">globalmeteornetwork.org</a><br><br>
<p>To see the meteors captured by the global meteor network, click the play button in the time control at the top of the 3D view window.</p>]]>
    </description>
    <Style>
      <ListStyle>
        <listItemType>checkHideChildren</listItemType>
      </ListStyle>
    </Style>`)


            //iterate over rows
            list.forEach((row) => {
                var item = [];

                switch(row.type){
                    case "group":
                    case "calc":
                    break;

                    case "header":
                    break;

                    case "row":
                    fileContents.push(`
      <Placemark>
        <TimeStamp><when>${row.columns[0].value}</when></TimeStamp>
        <LineString>
          <coordinates>${row.columns[5].value*1.},${row.columns[6].value*1.},${row.columns[7].value*1000.} ${row.columns[8].value*1.},${row.columns[9].value*1.},${row.columns[10].value*1000.}</coordinates>
          <altitudeMode>absolute</altitudeMode>
        </LineString>
      </Placemark>`)
                    break;
                }
            });

            fileContents.push(`
  </Document>
</kml>`);

            //trigger file download, passing the formatted data and mime type
            setFileContents(fileContents.join("\n"), "application/vnd.google-earth.kml+xml");
        }

        function clearFilter() {
            document.getElementById("stationsFilter").value = "";
            updateFilter();
        }

        function updateFilter() {
            var stationliststr = document.getElementById("stationsFilter").value;
            var stationlist = stationliststr.split(/, */);
            meteorTable.setFilter(customFilter, {stationlist: stationlist});
            document.getElementById("rowcount").innerHTML = meteorTable.getData('active').length;
            selectFov(stationlist, false);
            updatePermalink();
        }

        function customFilter(data, filterParams){
            var leafletId = data.leafletId;
            var selectedFeature = meteorLayer.getLayer(leafletId);
            if (filterParams.stationlist[0]==[""]) {
                L.DomUtil.removeClass(selectedFeature._path, 'filteredout-meteor');
                return true;
            } else {
                // rowstations contains any of the filterparams.stationlist
                var rowstations = data[stationsIndex];
                for (i=0; i<filterParams.stationlist.length; i++) {
                    if (rowstations.includes(filterParams.stationlist[i])) {
                        L.DomUtil.removeClass(selectedFeature._path, 'filteredout-meteor');
                        return true;
                    }
                }
                L.DomUtil.addClass(selectedFeature._path, 'filteredout-meteor');
                return false;
            }
        }

        function onclickStation(e) {
            deselectMeteors();
            var append = false;
            if (e.originalEvent.ctrlKey || e.originalEvent.metaKey || e.originalEvent.shiftKey) {
                append = true;
            }
            var stationsFilterBox = document.getElementById("stationsFilter");
            if (append) {
                stationsFilterBox.value = stationsFilterBox.value + "," + e.target.feature.properties.id;
            } else {
                deselectAllStations();
                stationsFilterBox.value = e.target.feature.properties.id;
            }
            selectStations(e.target.feature.properties.id.split(","), true);
            updateFilter();
            L.DomEvent.stop(e);
        }

        function onclickMeteor(e) {
            var clickedMeteorId = e.target.options.meteorId;
            selectMeteor(clickedMeteorId);
            L.DomEvent.stop(e);
        }

        function dailyMonthlyChange(loadData) {
            var dailyChecked = document.getElementById("dailymonthly_daily").checked;
            populateDropdown(dailyChecked, loadData);
        }

        function loadDataFromGMN() {
            var select = document.getElementById("datasetDropdown");
            getMeteorsFromUrl(select.value);
            updatePermalink();
        }

        function fixStationScale() {
            var currentZoom = mymap.getZoom();
            if (currentZoom <= 5) {
                var markerRadius = 12000;
            } else {
                var markerRadius = 2700;
            }
            for (stationId in stationLayers) {
                var stationLayer = stationLayers[stationId];
                for (var s=0; s<stationLayer.length; s++) {
                    stationLayer[s].setRadius(markerRadius);
                }
            }
        }

        function deselectAllStations() {
            for (stationId in stationLayers) {
                var stationLayer = stationLayers[stationId];
                for (var s=0; s<stationLayer.length; s++) {
                    stationLayer[s].setStyle({fillColor: "#3af"});
                }
            }
        }

        function deselectAllFov() {
            for (var i in fovLayers) {
                fovLayers[i].setStyle({fillColor: "#F33", fillOpacity:0.1});
            }
        }

        function selectFov(stations, appendToSelection) {
            if (!appendToSelection) {
                deselectAllFov();
            }
            for (var i=0; i<stations.length; i++) {
                if (stations[i] == "") {
                    continue;
                }
                if (!(stations[i] in fovLayers)) {
                    console.log("No FOV found for station " + stations[i]);
                    continue;
                } else {
                    var fovLayer = fovLayers[stations[i]];
                    fovLayer.setStyle({fillColor: "#00F", fillOpacity: 0.3});
                    fovLayer.bringToFront();
                }
            }
            reorderLayers();
        }

        function selectStations(stations, doSelect) {
            if (!doSelect) {
                doSelect = true;
            }
            for (var i=0; i<stations.length; i++) {
                if (stations[i] == "") {
                    continue;
                }
                if (!(stations[i] in stationLayers)) {
                    // We don't have a feature for this station
                    console.log("No feature found for station " + stations[i]);
                    continue;
                } else {
                    var stationLayer = stationLayers[stations[i]];
                    for (var s=0; s<stationLayer.length; s++) {
                        if (doSelect) {
                            stationLayer[s].setStyle({fillColor: "#f83"});
                        } else {
                            stationLayer[s].setStyle({fillColor: "#3af"});
                        }
                    }
                }
            }
        }

        function deselectMeteors() {
            for (var oldSelectedMeteorIdIndex in selectedMeteorIds) {
                var oldSelectedMeteorId = selectedMeteorIds[oldSelectedMeteorIdIndex];
                var selectedFeature = meteorLayer.getLayer(jsonData.data[oldSelectedMeteorId].leafletId);
                L.DomUtil.removeClass(selectedFeature._path, 'selected-meteor');
                selectStations(jsonData.data[oldSelectedMeteorId].stations, false);
            }
            selectStations(document.getElementById("stationsFilter").value.split(","), false);
            selectedMeteorIds = [];
        }

        function selectMeteor(meteorId) {
            if (true) { // TODO: multiple selection
                deselectMeteors();
            }
            var selectedLayer = meteorLayer.getLayer(jsonData.data[meteorId].leafletId);
            if (L.DomUtil.hasClass(selectedLayer._path, 'filteredout-meteor')) {
                clearFilter();
            }
            L.DomUtil.addClass(selectedLayer._path, 'selected-meteor');
            meteorLayer.getLayer(jsonData.data[meteorId].leafletId).bringToFront();
            selectedMeteorIds.push(meteorId * 1);
            meteorTable.deselectRow();
            meteorTable.selectRow(jsonData.data[meteorId][0]); // The table is indexed by element 0
            deselectAllStations();
            selectStations(jsonData.data[meteorId].stations, true);
            meteorTable.getSelectedRows()[0].scrollTo();
        }

        function getMeteorsFromUrl(url) {
            showLoading();
            $.getJSON('https://api.allorigins.win/get?url=' + encodeURIComponent(url) + '&callback=?', function (data) {
                if (!data.contents) {
                    console.log(url);
                }
                var csvData = data.contents.replace(/\r/g, '');
                addMeteorsToMap(csvData);
                hideLoading();
                panToExtent();
            });
        }

        function showLoading() {
            document.getElementById("loading").style.display = 'block';
        }

        function hideLoading() {
            document.getElementById("loading").style.display = 'none';
        }

        function populateDropdown(daily, loadData) {
            var select = document.getElementById("datasetDropdown");

            for (var i = select.options.length - 1; i >= 0; i--) {
                select.remove(i);
            }

            if (daily) {
                url = "https://www.tammo80.nl/camsfiles/daily/";
            } else {
                alert("No monthly data for CAMS yet!");
                return;
                url = "https://www.tammo80.nl/camsfiles/monthly/";
            }
            $.getJSON('https://api.allorigins.win/get?url=' + encodeURIComponent(url) + '&callback=?', function (data) {
                var parser = new DOMParser();
                var doc = parser.parseFromString(data.contents, "text/html");
                var docfrag = document.createDocumentFragment();

                if (daily) {
                    var base_address = "https://www.tammo80.nl/camsfiles/daily/";
                } else {
                    var base_address = "https://globalmeteornetwork.org/data/traj_summary_data/monthly/";
                }

                for (var i = 1, l=doc.links.length; i<l; i++) {
                    var filename = base_address + doc.links[i].getAttribute('href');
                    if (daily) {
                        var prettyname = filename.substr(43, filename.length - 47);
                    } else {
                        console.log(filename);
                        alert("No monthly data for CAMS yet!");
                        var prettyname = filename.substr(filename.length - 10, 4) + '-';
                        prettyname += filename.substr(filename.length - 6, 2);
                    }
                    docfrag.appendChild(new Option(prettyname, filename));
                }

                select.appendChild(docfrag);
                select.selectedIndex = select.options.length-1;
                if (loadData) {
                    loadDataFromGMN();
                }
            });
        }

        function panToExtent() {
            if (document.getElementById("stationsFilter").value=="") {
                return;
            }
            var tempLayer = new L.FeatureGroup();
            var meteors = meteorLayer.getLayers();
            for (var i=0; i<meteors.length; i++) {
                if (!L.DomUtil.hasClass(meteors[i]._path, 'filteredout-meteor')) {
                    tempLayer.addLayer(meteors[i]);
                }
            }
            if (tempLayer.getLayers().length > 0) {
                mymap.panTo(tempLayer.getBounds().getCenter(), 7);
            }
        }


        function onrightclickStation(e) {
            var props = e.target.feature.properties;
            var popupcontents = "<p>";
            if (props.link) {
                // Make up new istrastream links, assuming that if any station is on it, the rest will be as well.
                var stations = props.id.split(",");
                var firstStation = props.link.slice(-6);
                for (var i=0; i<stations.length; i++) {
                    popupcontents += `<a href="${props.link.replace(firstStation, stations[i])}" title="${stations[i]}" target="_blank">${stations[i]} on IstraStream</a><br />`;
                }
            } else {
                popupcontents = `${props.id} is not on IstraStream`;
            }
            popupcontents += "</p>"
            var popup = L.popup().setContent(popupcontents);
            popup.setLatLng(e.target.getLatLng());
            mymap.openPopup(popup);
        }

        function forEachStation(stationFeature, layer) {
            layer.on("click", onclickStation);
            layer.on("contextmenu", onrightclickStation);
            var tooltip = "";
            if (stationFeature.properties.name == "") {
                tooltip = stationFeature.properties.id;
            } else {
                tooltip = stationFeature.properties.name + " (" + stationFeature.properties.id + ")";
            }
            layer.bindTooltip(tooltip);
            var stationIds = stationFeature.properties.id.split(",");
            for (var stationIdIdx=0; stationIdIdx<stationIds.length; stationIdIdx++) {
                var stationId = stationIds[stationIdIdx];
                if (stationFeature.properties.id in stationLayers) {
                    stationLayers[stationId].push(layer);
                } else {
                    stationLayers[stationId] = [layer];
                }
            }
        }

        function loadCamsFov(kmlContents) {
            fovLayer.eachLayer(function (layer) {
                fovLayer.removeLayer(layer);
            });
            fovLayers = {};
            var layer = omnivore.kml.parse(kmlContents);
            layer.setStyle({fillColor: "#F33", fillOpacity: .1, stroke: false});
            layer.eachLayer(function (oneStationLayer) {
                var dummyLayer = new L.FeatureGroup(); // Mimic layout of RMS FOV
                oneStationLayer.addTo(dummyLayer);
                dummyLayer.addTo(fovLayer);
                var stationid = oneStationLayer.feature.id.replace(/^0*/, "");
                fovLayers[stationid] = dummyLayer;
            });
        }

        function loadFov() {
            var url = "https://www.tammo80.nl/camsfiles/cams_fov.kml";
            $.getJSON('https://api.allorigins.win/get?url=' + encodeURIComponent(url) + '&callback=?', function (data) {
                    loadCamsFov(data.contents);
            });
        }

        function fovClickHandler(e) {
            if (!mymap.hasLayer(fovLayer)) {
                return;
            }

            deselectAllStations();
            deselectAllFov();
            var clickBounds = L.latLngBounds(e.latlng, e.latlng);

            var clickedFov = [];

            for (var f in fovLayer._layers) {
                var feature = fovLayer._layers[f];
                var featurebounds = feature.getBounds();
                if (featurebounds && clickBounds.intersects(featurebounds)) { // Should be pip
                    var results = leafletPip.pointInLayer([e.latlng.lng, e.latlng.lat], feature);
                    if (results.length > 0) {
                        for (f1 in feature._layers) {
                            var stationid = feature._layers[f1].feature.id.replace(/^0*/, '');
                            clickedFov.push(stationid);
                        }
                    }
                }
            }

            document.getElementById("stationsFilter").value = clickedFov.join(",");
            selectStations(clickedFov);
            updateFilter();
        }

        function loadOneFov(url) {
            $.getJSON('https://api.allorigins.win/get?url=' + encodeURIComponent(url) + '&callback=?', function (data) {
                var layer = omnivore.kml.parse(data.contents);
                layer.setStyle({fillColor: "#F33", fillOpacity: .1, stroke: false});
                layer.addTo(fovLayer);
                for (f1 in layer._layers) {
                    var stationid = layer._layers[f1].feature.id;
                    fovLayers[stationid] = layer;
                }
            });
        }

        function addStationsToMap() {
            var emptyLayer = new L.FeatureGroup();

            var geojsonMarkerOptions = {
                radius: 2700,
                fillColor: "#3af",
                color: "#000",
                weight: 1,
                opacity: 1,
                fillOpacity: 0.7
            };

            function makeGeoJsonLayer(layer, stationfilename) {
                $.getJSON(stationfilename, function (data) {
                    locations = L.geoJson(data, {
                        onEachFeature: forEachStation,
                        pointToLayer: function (feature, latlng) {
                            return L.circle(latlng, geojsonMarkerOptions)
                        }
                    });

                    locations.addTo(layer);
                });
                layer.on("add", reorderLayers);
            }

            var camsStationLayer = new L.markerClusterGroup({showCoverageOnHover: false,
                 zoomToBoundsOnClick: false, maxClusterRadius:1});
            makeGeoJsonLayer(camsStationLayer, "cams-sites.json");

            var camsStationLayerDedup = new L.FeatureGroup();
            makeGeoJsonLayer(camsStationLayerDedup, "cams-sites-dedup.json");

            var rmsStationLayer = new L.FeatureGroup();
            makeGeoJsonLayer(rmsStationLayer, "rms-sites.json");

            stationMarkerLayers = [emptyLayer,
                                   camsStationLayer,
                                   camsStationLayerDedup,
                                   rmsStationLayer];

            L.control.layers({"No cameras": emptyLayer,
                              "CAMS cameras (grouped)": camsStationLayer,
                              "CAMS stations": camsStationLayerDedup,
                              "RMS stations": rmsStationLayer}, {
                "Meteors": meteorLayer,
                "Fields of view": fovLayer
            }).addTo(mymap);
        }

        function getColumnDefinitions(isCams) {
            function numStationsSorter(a, b, aRow, bRow, column, dir, sorterParams) {
                var lenA = a.split(/[,_]/).length;
                var lenB = b.split(/[,_]/).length;
                return lenB - lenA;
            }
            if (isCams) {
                var dateConcatMutator = function(value, data, type, params, component){
                  //value - original value of the cell
                  //data - the data for the row
                  //type - the type of mutation occurring  (data|edit)
                  //params - the mutatorParams object from the column definition
                  //component - when the "type" argument is "edit", this contains the cell component for the edited cell, otherwise it is the column component for the column'
                  var startDate = new Date(Date.parse(data[1] + " " + data[2] + "Z") + data[3] * 1000);
                  return startDate.toISOString().replace("T", " ").substr(0, 22);
                }

                var stationsMutator = function(value) {
                    return value.replaceAll("_", ",").slice(1);
                }

                return [
                    {title: "Number", field: "0"},
                    {title: "Start (UTC)", field: "sumcol", mutator: dateConcatMutator},
                    {title:"Vinf (km/s)", hozAlign:"right", field: "9"},
                    {title:"Int-mV (mag)", hozAlign:"right", field: "31"},
                    {title: "Stations", field: "34", sorter:numStationsSorter, mutator:stationsMutator},
                    {title: "LonBeg", hozAlign:"right", field: "17"},
                    {title: "LatBeg", hozAlign:"right", field: "15"},
                    {title:"Ht_beg (km)", hozAlign:"right", field: "19"},
                    {title: "LonEnd", hozAlign:"right", field: "23"},
                    {title: "LatEnd", hozAlign:"right", field: "21"},
                    {title:"Ht_end (km)", hozAlign:"right", field: "25"},
                ]
            } else {
                var showerMutator = function(value, data, type, params, component) {
                    if (value.trim() in establishedShowers) {
                        return establishedShowers[value.trim()];
                    } else if (value == "...") {
                        return "Sporadic";
                    } else {
                        return value.trim();
                    }
                }
                return [
                    {title:"Start (UTC)", field:"1"},
                    {title:"V_avg (km/s)", hozAlign:"right", field: "58"},
                    {title:"Duration (s)", hozAlign:"right", field: "72"},
                    {title:"Peak (abs mag)", hozAlign:"right", field: "73"},
                    {title:"Stations", field:"82", sorter:numStationsSorter},
                    {title: "LonBeg", hozAlign:"right", field: "62"},
                    {title: "LatBeg", hozAlign:"right", field: "60"},
                    {title:"Ht_beg (km)", hozAlign:"right", field: "64"},
                    {title: "LonEnd", hozAlign:"right", field: "68"},
                    {title: "LatEnd", hozAlign:"right", field: "66"},
                    {title:"Ht_end (km)", hozAlign:"right", field: "70"},
                    {title:"Shower", field:"3", mutator:showerMutator}
                    ]
            }
        }

        function addMeteorsToMap(csvData) {
            deselectMeteors();
            if ((!csvData.includes(';')) && !(csvData.includes(','))) {
                // Make CAMS format (fixed-width) ;-separated
                csvData = csvData.replace(/  */g, ";");
                csvData = csvData.replace(/^Ver.*/, "");
                csvData = csvData.replace(/Number.*/, "");
                csvData = csvData.replace(/^\n*-----[-;\n]*/, "");
            }
            jsonData = Papa.parse(csvData, {
                comments: "#",
                delimiter: ';',
                dynamicTyping: false,
                skipEmptyLines: true
            });

            if (jsonData.data[0].length == 83) {
                console.log("RMS format detected");
                chooseStationMarkerLayer(3);
                var lonBegIndex = 62;
                var latBegIndex = 60;
                var lonEndIndex = 68;
                var latEndIndex = 66;
                stationsIndex = 82;
                var isCams = false;
            } else if (jsonData.data[0].length == 35) {
                console.log("CAMS format detected");
                chooseStationMarkerLayer(2);
                var lonBegIndex = 17;
                var latBegIndex = 15;
                var lonEndIndex = 23;
                var latEndIndex = 21;
                stationsIndex = 34;
                var isCams = true;
            } else {
                console.log("Undetected format, num fields is " + jsonData.data[0].length)
            }

            meteorLayer.eachLayer(function (layer) {
                meteorLayer.removeLayer(layer);
            });

            for (meteorIndex in jsonData.data) {
                var lonBeg = jsonData.data[meteorIndex][lonBegIndex];
                var latBeg = jsonData.data[meteorIndex][latBegIndex];
                var lonEnd = jsonData.data[meteorIndex][lonEndIndex];
                var latEnd = jsonData.data[meteorIndex][latEndIndex];
                var stations = jsonData.data[meteorIndex][stationsIndex].replace(/^[_ ]/, "").split(/[,_]/);
                stations.forEach((name, index) => stations[index] = name.replace(/^0*/, ""));
                jsonData.data[meteorIndex].stations = stations;
                meteorFeature = L.polyline([[latBeg, lonBeg], [latEnd, lonEnd]], {className: 'unselected-meteor', meteorId: meteorIndex});
                meteorFeature.addTo(meteorLayer);
                meteorFeature.on("click", onclickMeteor);
                jsonData.data[meteorIndex].leafletId = meteorLayer.getLayerId(meteorFeature);
            }

            meteorTable.setColumns(getColumnDefinitions(isCams));
            meteorTable.setData(jsonData.data);
            document.getElementById("rowcount").innerHTML = meteorTable.getData('active').length;
        }
    </script>
</head>

<body>

    <h1>Meteor trajectory viewer</h1>
    <svg height="0" width="0" version="1.1" xmlns="http://www.w3.org/2000/svg" style="height:0; position:absolute; width:0">
        <defs>
          <linearGradient id="GradientUnselected">
            <stop offset="5%" stop-color="#FFFFF0" />
            <stop offset="95%" stop-color="#857f32" />
          </linearGradient>
          <linearGradient id="GradientSelected">
            <stop offset="5%" stop-color="#FFF" />
            <stop offset="95%" stop-color="#DB2721" />
          </linearGradient>
          <linearGradient id="GradientFilteredOut">
            <stop offset="5%" stop-color="#888" />
            <stop offset="95%" stop-color="#333" />
          </linearGradient>
        </defs>
      </svg>

    <p>Drag a SummaryMeteorLog file or a traj_summary file onto the map to view them. Or click below to load meteors
        from the Global Meteor Network. The data from the <a href="https://globalmeteornetwork.org/data/">Global Meteor
            Network</a> is used under a CC-BY 4.0 license.
          The maps on this website are therefore also licensed CC-BY 4.0. <b>Legend</b>: the meteors go in the direction from darker to white. So the white part of the trail is the lowest and last part of the trail.</p>
    <p>Link for the current selection: <a id="permalink" href="?data=latest_daily&stations=">here</a>.</p>

    <div id="gmnform">
    <select id="datasetDropdown" onChange="loadDataFromGMN()"></select>
    <input type="radio" id="dailymonthly_daily" name="dailymonthlyradio" value="daily" checked="checked" onChange="dailyMonthlyChange(true)" />
    <label for="daily"checked="true">Daily</label>
    <input type="radio" id="dailymonthly_monthly" name="dailymonthlyradio" value="monthly" onChange="dailyMonthlyChange(true)" />
    <label for="monthly">Monthly</label>
    </div>
    <div style="display:none" id="loading">Loading...</div>
    <br />
    <br />
    <div id="mapid"></div>
    <br />
    Filter stations: <input type="text" id="stationsFilter"></input>
    <button onclick="clearFilter()">❌</button>
    <button onclick="meteorTable.download('csv', 'meteors.csv')">Download selection as CSV</button><button onclick="meteorTable.download(kmlFormatter, 'meteors.kml')">Download selection as KML</button> Number of meteors: <span id="rowcount">0</span>
    <div id="meteortable"></div>
</body>
</html>
